package main

import (
	"reflect"
	"testing"
)

func TestCreateGraph(t *testing.T) {
	tables := []struct {
		grid  [][]string
		keys  map[string]int
		doors map[string]int
	}{
		{
			[][]string{
				{"#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "b", ".", "A", ".", "@", ".", "a", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#"},
			},
			map[string]int{"@": 14, "a": 16, "b": 10},
			map[string]int{"A": 12},
		},
	}
	for _, table := range tables {
		_, keys, doors := createGraph(table.grid)
		if !reflect.DeepEqual(keys, table.keys) || !reflect.DeepEqual(doors, table.doors) {
			t.Errorf("Output was incorrect, got: %v, %v, want: %v, %v", keys, doors, table.keys, table.doors)
		}
	}
}

func TestKeyIsBlocked(t *testing.T) {
	tables := []struct {
		grid    [][]string
		player  int
		key     int
		blocked bool
	}{
		{
			[][]string{
				{"#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "b", ".", "A", ".", "@", ".", "a", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#"},
			},
			14,
			10,
			true,
		},
		{
			[][]string{
				{"#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "b", ".", "A", ".", "@", ".", "a", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#"},
			},
			14,
			16,
			false,
		},
		{
			[][]string{
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "f", ".", "D", ".", "E", ".", "e", ".", "C", ".", "b", ".", "A", ".", "@", ".", "a", ".", "B", ".", "c", ".", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", ".", "#"},
				{"#", "d", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
			},
			39,
			25,
			true,
		},
	}
	for _, table := range tables {
		g, _, doors := createGraph(table.grid)
		blocked := keyIsBlocked(g, table.player, table.key, doors)
		if blocked != table.blocked {
			t.Errorf("Output was incorrect for key %v, got: %v, want: %v", table.key, blocked, table.blocked)
		}
	}
}
func TestTraverseMaze(t *testing.T) {
	tables := []struct {
		grid  [][]string
		steps int
	}{
		{
			[][]string{
				{"#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "b", ".", "A", ".", "@", ".", "a", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#"},
			},
			8,
		},
		{
			[][]string{
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "f", ".", "D", ".", "E", ".", "e", ".", "C", ".", "b", ".", "A", ".", "@", ".", "a", ".", "B", ".", "c", ".", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", ".", "#"},
				{"#", "d", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
			}, 86,
		},
		{
			[][]string{
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "b", ".", "C", ".", "D", ".", "f", "#"},
				{"#", ".", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", ".", ".", ".", ".", ".", "@", ".", "a", ".", "B", ".", "c", ".", "d", ".", "A", ".", "e", ".", "F", ".", "g", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
			}, 132,
		},
		{
			[][]string{
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "@", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "a", "c", ".", "G", "I", ".", "b", "#"},
				{"#", "#", "#", "d", "#", "e", "#", "f", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "#", "#", "A", "#", "B", "#", "C", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "#", "#", "g", "#", "h", "#", "i", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
				{"#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"},
			}, 81,
		},
	}
	for _, table := range tables {
		g, keys, doors := createGraph(table.grid)
		precomp := precomputeDistances(g, keys)
		steps := traverseMaze(g, doors, keys, precomp)
		if steps != table.steps {
			t.Errorf("Output was incorrect, got: %v, want: %v", steps, table.steps)
		}
	}
}

// func TestDistanceToKey(t *testing.T) {
// 	tables := []struct{
// 		grid [][]string
// 	}{}
// 	for _, table := range tables {
// 		if distance != table.distance {
// 			t.Errorf("Output was incorrect, got: %v, want: %v", steps, table.steps)
// 		}
// 	}
// }
